<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Forward Motion Dots</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
    </style>
</head>
<body>
    <canvas id="spaceCanvas"></canvas>

    <script>
        // 3D forward motion space dots
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('spaceCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                ctx.scale(dpr, dpr);
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Dot class with 3D positioning
            class Dot {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    const initial_z = 1000;
                    const p = 2000 / (initial_z + 2000);

                    const screenX = Math.random() * canvas.width;
                    const screenY = Math.random() * canvas.height;

                    this.x = (screenX - canvas.width / 2) / p + canvas.width / 2;
                    this.y = (screenY - canvas.height / 2) / p + canvas.height / 2;
                    this.z = initial_z;
                    
                    // Movement speed toward viewer
                    this.speed = 8 + Math.random() * 7;
                    
                    // Size and opacity based on distance
                    this.size = 0.5 + Math.random() * 1.5;
                    this.opacity = 0.3 + Math.random() * 0.7;
                    
                    // Color
                    const colors = [
                        '#ffffff', // White
                        '#ccccff', // Blue-ish
                        '#ffcaca', // Red-ish
                        '#caffca', // Green-ish
                        '#ffffcc'  // Yellow-ish
                    ];
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                }
                
                update() {
                    // Move toward viewer (decrease z)
                    this.z -= this.speed;
                    
                    // Reset when dot passes the viewer
                    if (this.z <= 0) {
                        this.reset();
                    }
                }
                
                draw() {
                    // Calculate screen position with perspective
                    const perspective = 2000 / (this.z + 2000);
                    const screenX = (this.x - canvas.width/2) * perspective + canvas.width/2;
                    const screenY = (this.y - canvas.height/2) * perspective + canvas.height/2;
                    
                    // Draw simple dot
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = this.opacity;
                    ctx.fillRect(screenX - this.size / 2, screenY - this.size / 2, this.size, this.size);
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // Create dots with reduced density for better performance
            const dots = [];
            const dotCount = 400;
            
            for (let i = 0; i < dotCount; i++) {
                dots.push(new Dot());
            }
            
            // Animation loop optimized for performance
            let lastTime = 0;
            const targetFPS = 60;
            const frameDuration = 1000 / targetFPS;
            
            function animate(currentTime) {
                // Throttle frame rate for better performance
                if (currentTime - lastTime < frameDuration) {
                    requestAnimationFrame(animate);
                    return;
                }
                lastTime = currentTime;
                
                // Clear canvas completely with black (removes any residual outline)
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw dots
                for (let i = 0; i < dots.length; i++) {
                    dots[i].update();
                    dots[i].draw();
                }
                
                requestAnimationFrame(animate);
            }
            
            // Start animation
            animate(0);
        });
    </script>
</body>
</html>